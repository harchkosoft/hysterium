<!DOCTYPE html>
<html>
<head>
    <title>GLITCH APOCALYPSE</title>
    <style>
        body { margin: 0; overflow: hidden; background: #000; }
        canvas { display: block; }
    </style>
</head>
<body>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        // Полноэкранный рендер
        const scene = new THREE.Scene();
        const camera = new THREE.OrthographicCamera(-1, 1, 1, -1, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer({ antialias: false });
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        // Глитч-шейдер для текста
        const textMaterial = new THREE.ShaderMaterial({
            uniforms: {
                time: { value: 0 },
                resolution: { value: new THREE.Vector2() },
                textTexture: { value: null }
            },
            vertexShader: `
                void main() {
                    gl_Position = vec4(position, 1.0);
                }
            `,
            fragmentShader: `
                uniform float time;
                uniform vec2 resolution;
                uniform sampler2D textTexture;

                float rand(vec2 co) {
                    return fract(sin(dot(co.xy, vec2(12.9898,78.233))) * 43758.5453);
                }

                void main() {
                    vec2 uv = gl_FragCoord.xy / resolution.xy;

                    // Дрожание экрана
                    uv.x += sin(time * 3.0 + uv.y * 5.0) * 0.02;
                    uv.y += cos(time * 2.5 + uv.x * 5.0) * 0.02;

                    // Пикселизация
                    vec2 pixelatedUV = floor(uv * vec2(32.0)) / vec2(32.0); // Разрешение сетки

                    // Искажение текстуры
                    vec2 distortedUV = uv;
                    distortedUV.x += sin(time * 5.0 + uv.y * 10.0) * 0.01;
                    distortedUV.y += cos(time * 3.0 + uv.x * 10.0) * 0.01;

                    // Цветовая дисторсия
                    vec3 col = vec3(0.0);
                    col.r = texture(textTexture, distortedUV + vec2(0.01, 0.0)).r;
                    col.g = texture(textTexture, distortedUV + vec2(-0.01, 0.0)).g;
                    col.b = texture(textTexture, distortedUV + vec2(0.0, 0.01)).b;

                    // Случайные полосы помех
                    if (rand(uv + floor(time * 10.0)) > 0.97) {
                        col = vec3(1.0, 0.0, 0.0) * 5.0;
                    }

                    // Волнистые искажения
                    float wave = sin(time * 10.0 + uv.x * uv.y * 100.0) * 0.3 + 0.7;
                    col *= wave;

                    // Постепенное безумие
                    if (time > 60.0) {
                        col = mix(col, 1.0 - col, smoothstep(60.0, 120.0, time));
                        uv *= 1.0 + 0.5 * sin(time * 20.0);
                    }

                    gl_FragColor = vec4(clamp(col, 0.0, 1.0), 1.0);
                }
            `
        });

        // Создание текстовой текстуры
        function createTextTexture(text, fontSize = 64, textColor = '#ffffff', bgColor = '#000000') {
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');
            const padding = 20;

            // Определяем размеры текста
            ctx.font = `${fontSize}px monospace`;
            const textWidth = ctx.measureText(text).width;
            const textHeight = fontSize;

            // Устанавливаем размеры холста
            canvas.width = textWidth + padding * 2;
            canvas.height = textHeight + padding * 2;

            // Рисуем фон
            ctx.fillStyle = bgColor;
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Рисуем текст
            ctx.fillStyle = textColor;
            ctx.font = `${fontSize}px monospace`;
            ctx.fillText(text, padding, fontSize + padding / 2);

            // Создаем текстуру
            const texture = new THREE.CanvasTexture(canvas);
            texture.minFilter = THREE.LinearFilter;
            return texture;
        }

        // Текстовая текстура
        const textTexture = createTextTexture('harchkosoft');
        textMaterial.uniforms.textTexture.value = textTexture;

        // Плоскость для текста
        const textGeometry = new THREE.PlaneGeometry(2, 1);
        const textMesh = new THREE.Mesh(textGeometry, textMaterial);
        scene.add(textMesh);

        // Звуковая система в стиле чиптюн
        class AudioHell {
            constructor() {
                this.audioContext = new (window.AudioContext || window.webkitAudioContext)();
                this.gainNode = this.audioContext.createGain();
                this.startTime = this.audioContext.currentTime;
                this.oscillators = []; // Инициализируем массив осцилляторов
                
                // Настройки звука
                this.gainNode.gain.value = 0.3;
                this.init();
            }

            init() {
                // Создаем осцилляторы с разными волнами
                const waveTypes = ['square', 'sawtooth'];
                waveTypes.forEach(type => {
                    const osc = this.audioContext.createOscillator();
                    osc.type = type;
                    osc.frequency.setValueAtTime(
                        50 + Math.random() * 500, // Ограничение частоты
                        this.audioContext.currentTime
                    );
                    osc.connect(this.gainNode);
                    this.oscillators.push(osc); // Добавляем осциллятор в массив
                });

                // Подключаем обработку
                this.gainNode.connect(this.audioContext.destination);
                
                // Запуск осцилляторов
                this.oscillators.forEach(osc => osc.start());
            }

            updateVolume(value) {
                this.gainNode.gain.setValueAtTime(
                    value,
                    this.audioContext.currentTime
                );
            }

            triggerEvent() {
                // Басовый всплеск
                const bassOsc = this.audioContext.createOscillator();
                bassOsc.type = 'square';
                bassOsc.frequency.setValueAtTime(
                    50 + Math.random() * 100, // Низкая частота
                    this.audioContext.currentTime
                );

                // Шумовой эффект
                const noiseOsc = this.audioContext.createBufferSource();
                const bufferSize = this.audioContext.sampleRate * 0.1; // 0.1 секунды
                const buffer = this.audioContext.createBuffer(1, bufferSize, this.audioContext.sampleRate);
                const data = buffer.getChannelData(0);
                for (let i = 0; i < bufferSize; i++) {
                    data[i] = Math.random() * 2 - 1; // White noise
                }
                noiseOsc.buffer = buffer;

                // Подключаем к гейну
                bassOsc.connect(this.gainNode);
                noiseOsc.connect(this.gainNode);

                // Резкое изменение громкости
                this.gainNode.gain.setValueAtTime(0.8, this.audioContext.currentTime);
                this.gainNode.gain.exponentialRampToValueAtTime(0.01, this.audioContext.currentTime + 0.1);

                // Запуск и остановка через короткое время
                bassOsc.start();
                noiseOsc.start();
                setTimeout(() => {
                    bassOsc.stop();
                    noiseOsc.stop();
                }, 100 + Math.random() * 100);
            }
        }

        const audio = new AudioHell();

        // Система прогрессии
        class ChaosController {
            constructor() {
                this.startTime = Date.now();
                this.maxDuration = 300000; // 5 минут
                this.hellInterval = setInterval(() => this.update(), 10); // Уменьшаем интервал до 10 мс
            }

            update() {
                const elapsed = Date.now() - this.startTime;
                const progress = Math.min(elapsed / this.maxDuration, 1.0);
                
                // Плавное нарастание громкости
                audio.updateVolume(0.2 + progress * 0.6);

                // Внезапные события
                if (Math.random() > 0.9) {
                    this.triggerEvent();
                }
            }

            triggerEvent() {
                // Визуальные искажения
                textMaterial.uniforms.resolution.value.set(
                    window.innerWidth * (0.8 + Math.random() * 0.4),
                    window.innerHeight * (0.8 + Math.random() * 0.4)
                );
                
                // Звуковые всплески
                audio.triggerEvent();
            }
        }

        const chaos = new ChaosController();

        // Анимация
        function animate() {
            requestAnimationFrame(animate);
            textMaterial.uniforms.time.value = (Date.now() - chaos.startTime) * 0.001;
            renderer.render(scene, camera);
        }

        animate();

        // Обработка ресайза
        window.addEventListener('resize', () => {
            renderer.setSize(window.innerWidth, window.innerHeight);
            textMaterial.uniforms.resolution.value.set(
                window.innerWidth,
                window.innerHeight
            );
        });

        // Активация звука по клику
        document.addEventListener('click', () => {
            if (audio.audioContext.state === 'suspended') {
                audio.audioContext.resume();
            }
        });
    </script>
</body>
</html>